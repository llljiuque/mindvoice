# MindVoice 项目编程规则

## 项目概述
MindVoice 是一个结合语音识别(ASR)和大语言模型(LLM)的智能桌面助手，采用 Electron + React + Python FastAPI 架构。

## 时间和日期规则

### 当前时间使用
- **获取当前日期**: 必须使用系统提供的当前日期，不要使用硬编码的过期日期
- **日期格式**: 
  - 显示格式: `YYYY-MM-DD` (如 2025-12-31)
  - 时间戳格式: ISO 8601 格式
- **时区**: 默认使用本地时区
- **注意事项**: 
  - 生成代码时如需示例日期，使用相对时间描述（如"今天"、"昨天"）
  - 不要在代码中硬编码过期的日期
  - 日志和记录必须使用实际的当前时间

### 版本发布日期
- 版本发布日期应该是实际发布的日期
- 更新版本时同步更新发布日期为当前日期

## 版本管理规则

### 全局版本号
- **唯一来源**: `electron-app/src/version.ts` 中的 `APP_VERSION` 对象
- **版本号格式**: 遵循语义化版本规范 (Semantic Versioning: MAJOR.MINOR.PATCH)
- **修改原则**: 
  - 只在 `version.ts` 中修改版本号
  - 同步更新 `package.json` 中的 version 字段
  - 更新发布日期 releaseDate
- **引用方式**: 所有需要版本号的地方都从 `version.ts` 导入

```typescript
import { APP_VERSION } from './version';
const version = APP_VERSION.version;
```

## 架构规则

### Python 后端 (FastAPI)
- **虚拟环境**: 所有 Python 命令必须在 venv 中执行
  ```bash
  source venv/bin/activate  # 先激活虚拟环境
  python xxx.py
  ```

### 前端架构 (Electron + React)
- **应用类型**: 支持多个独立应用 (voice-note, voice-chat)
- **状态管理**: 使用 React Hooks (useState, useEffect, useRef)
- **通信方式**: WebSocket 用于实时数据流，REST API 用于控制操作

### 数据流规则
- **音频流**: 音频流不经过主窗口，通过 voice_input 虚拟键盘直接流向主窗口
- **不使用"recording"术语**: 将 voice_input 逻辑视为语音输入的虚拟键盘
- **ASR状态**: idle → recording → stopping → idle

## API 响应格式规则

### LLM API 响应格式
AI 助手必须输出 JSON 格式响应，包含以下字段：
```json
{
  "answer_user": "要显示给用户的完整句子",
  "other_data": "其他结构化数据用于处理"
}
```
- **关键规则**: 如果 JSON 中没有 `answer_user` 字段，则不在聊天界面显示任何内容
- **用途**: `answer_user` 用于用户界面展示，其他字段用于程序处理

### 通用 API 响应
```json
{
  "success": true,
  "message": "操作描述",
  "data": {}
}
```

## 代码风格规则

### TypeScript/React
- 使用函数组件和 Hooks
- 组件文件命名: PascalCase (如 `VoiceNote.tsx`)
- 样式文件与组件同名 (如 `VoiceNote.css`)
- 类型定义优先使用 interface
- 避免使用 any，使用具体类型
- Props 类型定义: `interface ComponentNameProps`

### Python
- 遵循 PEP 8 规范
- 类名: PascalCase (如 `BaseASR`)
- 函数/变量名: snake_case (如 `start_recording`)
- 使用类型注解 (Type Hints)
- 文档字符串使用 Google 风格

### 命名规范
- 文件夹: kebab-case (如 `voice-note`)
- 常量: UPPER_SNAKE_CASE (如 `API_BASE_URL`)
- 布尔变量: 使用 is/has/should 前缀 (如 `isConnected`)

## 文件组织规则

### 前端目录结构
```
electron-app/
├── src/
│   ├── components/
│   │   ├── apps/          # 应用组件
│   │   │   ├── VoiceNote/
│   │   │   └── VoiceChat/
│   │   └── shared/        # 共享组件
│   ├── utils/             # 工具函数
│   ├── version.ts         # ⭐ 全局版本号配置
│   ├── App.tsx            # 主应用
│   └── main.tsx
```

### 后端目录结构
```
src/
├── api/                   # API 服务
├── core/                  # 核心功能
├── providers/             # 服务提供者
│   ├── asr/              # 语音识别
│   ├── llm/              # 大语言模型
│   └── storage/          # 存储
└── services/             # 业务服务
```

## 测试规则

### 测试策略
- **仅测试关键模块**: 不需要为所有模块编写测试
- **关键模块**: ASR、LLM、WebSocket 连接、数据存储
- **不创建独立测试程序**: 测试集成在项目中，避免独立测试文件
- **测试类型**: 
  - 单元测试: 核心功能模块
  - 集成测试: 关键业务流程

### ASR 调试日志控制
- **配置文件**: `asr_debug_config.h` (如果存在)
- **控制方式**: 通过注释/取消注释 `#define ASR_LOG_DEBUG` 来开关调试日志
- **不使用 CMake**: 不在 CMake 中定义日志级别，统一在配置头文件中管理

## WebSocket 规则

### 消息类型
```typescript
type WSMessageType = 
  | 'initial_state'  // 初始状态
  | 'text_update'    // 中间结果（实时更新）
  | 'text_final'     // 确定结果（完整utterance）
  | 'state_change'   // 状态变更
  | 'error';         // 错误
```

### 连接管理
- 自动重连: 连接断开后 3 秒自动重连
- 心跳检测: 定期检查 API 连接状态（5秒间隔）
- 状态同步: WebSocket 连接成功后同步初始状态

## 数据持久化规则

### 历史记录
- 每条记录包含: id, text, metadata, created_at, app_type
- app_type: 标识记录来源应用 (voice-note, voice-chat)
- 分页加载: 每页 20 条记录
- 支持按应用类型筛选

### 保存逻辑
```typescript
// 保存时必须指定 app_type
{
  text: string,
  app_type: 'voice-note' | 'voice-chat'
}
```

## 数据库技术规范 ⭐

### 数据库选型
- **主数据库**: SQLite 3
- **位置**: 由 `config.yml` 中的 `storage.data_dir` + `storage.database` 配置决定
- **用途**: 存储所有应用的历史记录、元数据、笔记信息
- **共享机制**: 3个应用（voice-note, voice-chat, voice-zen）共享同一数据库，通过 `app_type` 字段区分
- **路径处理**: 使用 `Path(db_path).expanduser()` 展开 `~` 为用户主目录

### 统一存储配置

**配置结构**（`config.yml`）：
```yaml
storage:
  data_dir: <平台相关路径>  # 数据根目录
  database: database/history.db    # 数据库相对路径
  images: images                   # 图片目录相对路径
  knowledge: knowledge             # 知识库目录相对路径
  backups: backups                 # 备份目录相对路径
```

**跨平台数据目录规范**：
- **macOS**: `~/Library/Application Support/MindVoice`
- **Linux**: `~/.local/share/MindVoice`
- **Windows**: `%APPDATA%\MindVoice` (通常是 `C:\Users\用户名\AppData\Roaming\MindVoice`)
- **iOS**: `~/Documents/MindVoice`
- **Android**: `/data/data/com.mindvoice.app/files/MindVoice`
- **通用简化**: `~/MindVoice` (桌面平台均可用)

**Electron 缓存目录**（独立于应用数据）：
- **macOS**: `~/Library/Application Support/MindVoice-App`
- **Linux**: `~/.config/MindVoice-App`
- **Windows**: `%APPDATA%\MindVoice-App`
- **作用**: 存储 Electron/Chromium 的浏览器缓存、Cookie、Local Storage 等

**目录结构**：
```
<data_dir>/  (应用数据，平台相关)
├── database/
│   └── history.db                        # 历史记录数据库
├── images/
│   └── *.png                             # 用户上传的图片
├── knowledge/
│   ├── chroma/                           # 向量数据库
│   │   └── chroma.sqlite3
│   └── files/                            # 原始知识库文件
│       └── *.md, *.txt
└── backups/
    └── *.db.backup                       # 数据库备份
```

**路径处理规范**：
```python
# Python 代码中读取配置（跨平台）
from src.utils.platform_paths import expand_data_dir

storage_config = config['storage']
data_dir = expand_data_dir(storage_config['data_dir'])  # 自动展开 ~ 和环境变量
db_path = data_dir / storage_config['database']
images_dir = data_dir / storage_config['images']
```

```bash
# Shell 脚本中读取配置（跨平台兼容）
DATA_DIR_RAW=$(grep '^\s*data_dir:' config.yml | sed 's/.*data_dir:\s*//; s/#.*//; s/^[[:space:]]*//; s/[[:space:]]*$//')
DATA_DIR="${DATA_DIR_RAW/#\~/$HOME}"  # 展开 ~ 为 $HOME
DB_PATH="$DATA_DIR/database/history.db"
```

**初始化配置**：
```bash
# 自动生成适合当前平台的配置
python scripts/init_config.py
```

### 数据库表结构

#### records 表（里程碑基准版本）
```sql
CREATE TABLE IF NOT EXISTS records (
    id TEXT PRIMARY KEY,
    text TEXT NOT NULL,
    metadata TEXT,
    app_type TEXT NOT NULL DEFAULT 'voice-note',
    created_at TIMESTAMP NOT NULL
);
```

**字段说明**：
- `id`: 记录ID，UUID v4 格式
- `text`: 纯文本内容，用于搜索和预览
- `metadata`: JSON 格式元数据（blocks、noteInfo 等）
- `app_type`: 应用类型，必需字段（voice-note/voice-chat/voice-zen）
- `created_at`: 创建时间，必需字段，本地时间格式 `YYYY-MM-DD HH:MM:SS`

### metadata 字段结构
```json
{
  "blocks": [
    {
      "id": "block-xxx",
      "type": "paragraph",
      "content": "段落内容",
      "startTime": 1704254400000,
      "endTime": 1704254410000,
      "isAsrWriting": false
    }
  ],
  "noteInfo": {
    "title": "会议纪要",
    "type": "会议",
    "relatedPeople": "张三, 李四",
    "location": "会议室A",
    "startTime": "2026-01-04 10:00:00",
    "endTime": "2026-01-04 11:30:00"
  },
  "language": "zh-CN",
  "provider": "volcano",
  "app_type": "voice-note"
}
```

### 时间处理规范

#### 本地时间保存
```python
from datetime import datetime

def save_record(self, text: str, metadata: Dict[str, Any]) -> str:
    created_at = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cursor.execute('''
        INSERT INTO records (id, text, metadata, app_type, created_at)
        VALUES (?, ?, ?, ?, ?)
    ''', (record_id, text, json_metadata, app_type, created_at))
```

#### 路径展开
```python
from pathlib import Path

db_path = config.get('path', 'history.db')
self.db_path = Path(db_path).expanduser()  # 展开 ~ 为用户主目录
```

### 数据库操作规范

#### 1. 创建记录
```python
def save_record(self, text: str, metadata: Dict[str, Any]) -> str:
    """创建新记录"""
    import uuid
    record_id = str(uuid.uuid4())
    app_type = metadata.get('app_type', 'voice-note')
    created_at = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    cursor.execute('''
        INSERT INTO records (id, text, metadata, app_type, created_at)
        VALUES (?, ?, ?, ?, ?)
    ''', (record_id, text, json.dumps(metadata, ensure_ascii=False), app_type, created_at))
    
    return record_id
```

#### 2. 更新记录
```python
def update_record(self, record_id: str, text: str, metadata: Dict[str, Any]) -> bool:
    """更新已有记录"""
    cursor.execute('''
        UPDATE records
        SET text = ?, metadata = ?
        WHERE id = ?
    ''', (text, json.dumps(metadata, ensure_ascii=False), record_id))
    
    return cursor.rowcount > 0
```

#### 3. 查询记录
```python
def get_record(self, record_id: str) -> Optional[Dict[str, Any]]:
    """获取单条记录"""
    cursor.execute('''
        SELECT id, text, metadata, app_type, created_at
        FROM records
        WHERE id = ?
    ''', (record_id,))
    
    row = cursor.fetchone()
    if row:
        return {
            'id': row[0],
            'text': row[1],
            'metadata': json.loads(row[2]) if row[2] else {},
            'app_type': row[3] or 'voice-note',
            'created_at': row[4]
        }
    return None
```

#### 4. 列表查询
```python
def list_records(self, limit: int = 100, offset: int = 0, app_type: Optional[str] = None):
    """查询记录列表，按创建时间倒序"""
    if app_type:
        cursor.execute('''
            SELECT id, text, metadata, app_type, created_at
            FROM records
            WHERE app_type = ?
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        ''', (app_type, limit, offset))
    else:
        cursor.execute('''
            SELECT id, text, metadata, app_type, created_at
            FROM records
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        ''', (limit, offset))
```

### 数据恢复规范

#### 前端恢复逻辑
```typescript
// 从数据库恢复记录
const loadRecord = async (recordId: string) => {
  const response = await fetch(`${API_BASE_URL}/api/records/${recordId}`);
  const data = await response.json();
  
  if (data.text) {
    setText(data.text);
    
    // 优先使用 metadata.blocks
    if (data.metadata?.blocks?.length > 0) {
      setInitialBlocks(data.metadata.blocks);
    } else {
      // 降级：从纯文本创建 blocks
      const textBlocks = data.text.split('\n')
        .filter(line => line.trim())
        .map((line, index) => ({
          id: `block-restored-${Date.now()}-${index}`,
          type: 'paragraph',
          content: line,
          isAsrWriting: false,
        }));
      setInitialBlocks([noteInfoBlock, ...textBlocks]);
    }
  }
};
```

### 数据库维护

#### 数据备份
```bash
# 获取数据库路径（从config.yml读取）
DB_PATH=$(grep 'path:' config.yml | awk '{print $2}' | sed 's/~/$HOME/g')

# 手动备份
cp "$DB_PATH" "${DB_PATH}.backup"

# 查看记录数
sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM records;"
```

#### 数据库重建
```bash
# 使用提供的脚本（自动从config.yml读取路径）
./scripts/rebuild_database.sh
```

### 性能优化

#### 索引建议
```sql
-- 按创建时间倒序查询
CREATE INDEX idx_created_at ON records(created_at DESC);

-- 按应用类型筛选
CREATE INDEX idx_app_type ON records(app_type);

-- 组合索引
CREATE INDEX idx_app_type_created_at ON records(app_type, created_at DESC);
```

## 图片处理规范 ⭐

### 图片存储架构

#### 存储位置
- **图片文件**: `data/images/{timestamp}-{hash}.{ext}`
- **数据库**: metadata.blocks 中的 imageUrl 字段
- **格式**: 相对路径，如 `images/261619072-6ddaa776.png`

#### 图片块结构
```typescript
{
  id: "block-xxx",
  type: "image",
  content: "",  // 图片块的 content 为空字符串
  imageUrl: "images/261619072-6ddaa776.png",  // 相对路径
  imageCaption?: "图片说明"  // 可选的说明文字
}
```

### 图片上传流程

#### 前端上传
```typescript
// BlockEditor.tsx - 粘贴图片处理
const reader = new FileReader();
reader.onload = async (event) => {
  const base64Data = event.target?.result as string;
  
  // 调用API上传
  const response = await fetch(`${API_BASE_URL}/api/images/save`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ image_data: base64Data })
  });
  
  const result = await response.json();
  // result.image_url = "images/261619072-6ddaa776.png"
};
```

#### 后端保存
```python
# server.py - 图片保存API
@app.post("/api/images/save")
async def save_image(request: SaveImageRequest):
    # 1. 解码 Base64
    image_bytes = base64.b64decode(image_data)
    
    # 2. 生成唯一文件名
    timestamp = int(time.time() * 1000)
    hash_str = hashlib.md5(image_bytes[:1024]).hexdigest()[:8]
    filename = f"{timestamp}-{hash_str}.{ext}"
    
    # 3. 保存到 data/images/
    image_path = project_root / "data" / "images" / filename
    with open(image_path, 'wb') as f:
        f.write(image_bytes)
    
    # 4. 返回相对路径
    return {"success": True, "image_url": f"images/{filename}"}
```

### 图片保存到数据库

#### text 字段处理规范 ⚠️ 重要
**规则**: text 字段必须包含图片占位符，确保从纯文本恢复时不丢失图片信息

```typescript
// VoiceNoteAdapter.ts - toSaveData()
const textContent = blocks
  .filter(b => b.type !== 'note-info' && !b.isBufferBlock)
  .map(b => {
    if (b.type === 'image') {
      // ✅ 正确：添加图片占位符
      return `[IMAGE: ${b.imageUrl || ''}]${b.imageCaption ? ' ' + b.imageCaption : ''}`;
    }
    return b.content;
  })
  .filter(text => text.trim())
  .join('\n');
```

**禁止做法**：
```typescript
// ❌ 错误：图片块被过滤掉，导致纯文本恢复时丢失
const textContent = blocks
  .filter(b => b.type !== 'note-info' && !b.isBufferBlock)
  .map(b => b.content)  // 图片块的 content 为空
  .filter(text => text.trim())  // 空字符串被过滤
  .join('\n');
```

#### metadata 字段
- `metadata.blocks` 数组包含完整的图片块信息
- 保留 `imageUrl` 相对路径
- 保留 `imageCaption` 说明文字

### 图片恢复流程

#### 从 blocks 恢复（推荐）
```typescript
// App.tsx - loadRecord()
if (data.metadata?.blocks && Array.isArray(data.metadata.blocks) && data.metadata.blocks.length > 0) {
  // 直接使用 blocks，包含完整的图片块信息
  setInitialBlocks(data.metadata.blocks);
}
```

#### 从纯文本恢复（降级方案）
```typescript
// App.tsx - loadRecord()
else {
  // 解析 text 字段中的图片占位符
  const textBlocks = data.text.split('\n')
    .filter(line => line.trim())
    .map((line, index) => {
      // 检测图片占位符
      const imageMatch = line.match(/^\[IMAGE: (.*?)\](.*)?$/);
      if (imageMatch) {
        return {
          id: `block-restored-${timestamp}-${index}`,
          type: 'image',
          content: '',
          imageUrl: imageMatch[1],
          imageCaption: imageMatch[2]?.trim() || undefined,
        };
      }
      return {
        id: `block-restored-${timestamp}-${index}`,
        type: 'paragraph',
        content: line,
        isAsrWriting: false,
      };
    });
  
  setInitialBlocks([noteInfoBlock, ...textBlocks]);
}
```

#### 图片URL渲染
```typescript
// BlockEditor.tsx - 渲染图片块
if (block.type === 'image') {
  const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://127.0.0.1:8765';
  const imageUrl = block.imageUrl?.startsWith('http') 
    ? block.imageUrl 
    : `${API_BASE_URL}/api/${block.imageUrl}`;  // 拼接完整URL
  
  return <img src={imageUrl} alt={block.imageCaption || '图片'} />;
}
```

### 图片文件管理

#### 当前限制 ⚠️
1. **孤儿文件**: 删除历史记录时，图片文件不会自动删除
2. **文件累积**: 长期使用会导致 `data/images/` 目录体积增大
3. **备份不完整**: 仅备份数据库不包含图片文件

#### 手动清理
```bash
# 查看图片目录大小
du -sh data/images/

# 手动删除旧图片（慎用，可能导致历史记录中的图片失效）
find data/images/ -type f -mtime +90 -delete
```

#### 未来改进方向
1. **引用计数**: 在数据库中记录图片被引用次数
2. **垃圾回收**: 定期清理未被引用的图片文件
3. **完整备份**: 备份时同时打包图片文件
4. **导出功能**: 导出为 ZIP（markdown + images）

### 图片处理最佳实践

#### ✅ 应该做的
1. **保存时**: 在 text 字段添加图片占位符
2. **恢复时**: 优先使用 blocks，降级到解析 text
3. **渲染时**: 添加 onError 处理图片加载失败
4. **删除时**: 考虑图片文件是否需要清理

#### ❌ 不应该做的
1. 不要在 text 字段中遗漏图片块
2. 不要在 metadata 中存储 Base64（体积太大）
3. 不要直接删除 `data/images/` 目录
4. 不要在前端硬编码图片绝对路径

### 图片API端点

#### 上传图片
- **端点**: `POST /api/images/save`
- **请求**: `{ image_data: "data:image/png;base64,..." }`
- **响应**: `{ success: true, image_url: "images/xxx.png" }`

#### 获取图片
- **端点**: `GET /api/images/{filename}`
- **响应**: 图片文件（FileResponse）
- **安全**: 防止路径遍历攻击（检查 `..`、`/`、`\`）

### 图片相关错误处理

#### 前端错误处理
```typescript
// 图片加载失败
<img 
  src={imageUrl}
  onError={(e) => {
    console.error('[BlockEditor] 图片加载失败:', imageUrl);
    e.currentTarget.style.display = 'none';
    // 显示错误提示
  }}
/>
```

#### 后端错误处理
```python
# 图片文件不存在
if not image_path.exists():
    raise HTTPException(status_code=404, detail="图片不存在")

# 无效的文件名
if '..' in filename or '/' in filename:
    raise HTTPException(status_code=400, detail="无效的文件名")
```

## 错误处理规则

### 前端错误处理
- 网络错误: 显示 Toast 提示，不中断用户操作
- API 错误: 显示错误横幅，提供重试机制
- WebSocket 错误: 自动重连，不打断用户

### 后端错误处理
- 返回统一错误格式
- 记录详细错误日志
- 区分用户错误和系统错误

## UI/UX 规则

### 状态指示
- ASR 状态: 通过 StatusIndicator 组件显示
- 连接状态: API 连接状态实时显示
- 加载状态: 使用 loading 状态避免重复点击

### Toast 通知
- 成功操作: 'success' 类型（绿色）
- 错误操作: 'error' 类型（红色）
- 提示信息: 'info' 类型（蓝色）
- 自动关闭: 3秒后自动消失

## 配置管理规则

### 配置文件
- 示例配置: `config.yml.example`
- 实际配置: `config.yml` (不提交到版本控制)
- 配置加载: 启动时从 config.yml 加载

### 配置文件同步规则 ⭐
- **重要原则**: 添加或修改配置项时，必须**同时更新** `config.yml` 和 `config.yml.example`
- **同步范围**: 
  - ✅ 配置项的键名和结构
  - ✅ 配置项的注释和说明
  - ✅ 配置项的默认值
  - ❌ 令牌、密钥等敏感信息（仅在 `config.yml` 中有真实值）
- **示例配置文件规则**:
  - `config.yml.example` 中的密钥/令牌字段留空或使用占位符（`""`）
  - 必须包含详细的注释说明每个配置项的用途
- **实际配置文件规则**:
  - `config.yml` 包含真实的密钥和令牌
  - 不提交到版本控制（已在 `.gitignore` 中）
  
**修改流程**:
1. 在 `config.yml.example` 中添加新配置项（带注释）
2. 在 `config.yml` 中添加相同配置项（可含真实值）
3. 确保两个文件的结构一致

### 环境变量
- API 地址: `API_BASE_URL`
- WebSocket 地址: `WS_URL`
- 开发环境使用本地地址

## Git 规则

### 提交信息格式
```
<type>(<scope>): <subject>

type: feat|fix|docs|style|refactor|test|chore
scope: component|api|asr|llm|ui
subject: 简短描述（中文）
```

示例:
```
feat(ui): 添加关于页面
fix(asr): 修复WebSocket重连问题
docs(readme): 更新安装说明
```

### 不提交的文件
- `venv/` - Python 虚拟环境
- `node_modules/` - Node 依赖
- `config.yml` - 配置文件
- `*.pyc` - Python 编译文件
- `dist/` - 构建产物

## 性能优化规则

### 前端性能
- 使用 React.memo 避免不必要的重渲染
- 大列表使用虚拟滚动
- 防抖/节流处理高频事件

### 后端性能
- 异步处理音频流
- 使用连接池管理数据库连接
- 实现合理的缓存策略

## 安全规则

### API 安全
- 输入验证: 所有用户输入必须验证
- XSS 防护: 文本内容正确转义
- CORS 配置: 仅允许特定来源

### 数据安全
- 敏感信息不记录到日志
- API Key 存储在配置文件中
- 不在前端暴露敏感配置

## 文档规则

### 代码注释
- 复杂逻辑必须添加注释
- 公共 API 必须有文档字符串
- 注释使用中文，清晰简洁

### 项目文档
- `README.md`: 项目介绍和快速开始
- `docs/`: 详细架构和设计文档
- 重要变更更新 CHANGELOG

## 开发工具规则

### 推荐扩展
- ESLint: 代码检查
- Prettier: 代码格式化
- Python (Pylance): Python 支持

### 命令快捷方式
```bash
# 启动开发服务
./quick_start.sh

# 停止服务
./stop.sh
```

## 关于页面规则

### 必需信息
- 开发者: 深圳王哥 & AI
- 联系方式: manwjh@126.com
- 版本号: 从 `version.ts` 导入
- 发布日期: 从 `version.ts` 导入

### 版本更新流程
1. 修改 `electron-app/src/version.ts`
2. 同步更新 `electron-app/package.json` 的 version 字段
3. 更新 releaseDate 为发布日期（使用当前实际日期）
4. 在 CHANGELOG 中记录变更（如果有）

### 快捷更新方式
使用提供的脚本快速更新版本号：
```bash
# 自动使用当前日期作为发布日期
./update_version.sh 1.1.0

# 或指定发布日期
./update_version.sh 1.1.0 2025-12-31
```

---

**注意**: 这些规则是项目的编码标准，所有贡献者必须遵守。如有疑问或需要调整规则，请与项目维护者讨论。

