# MindVoice 项目编程规则

## 项目概述
MindVoice 是一个结合语音识别(ASR)和大语言模型(LLM)的智能桌面助手，采用 Electron + React + Python FastAPI 架构。

## 时间和日期规则

### 当前时间使用
- **获取当前日期**: 必须使用系统提供的当前日期，不要使用硬编码的过期日期
- **日期格式**: 
  - 显示格式: `YYYY-MM-DD` (如 2025-12-31)
  - 时间戳格式: ISO 8601 格式
- **时区**: 默认使用本地时区
- **注意事项**: 
  - 生成代码时如需示例日期，使用相对时间描述（如"今天"、"昨天"）
  - 不要在代码中硬编码过期的日期
  - 日志和记录必须使用实际的当前时间

### 版本发布日期
- 版本发布日期应该是实际发布的日期
- 更新版本时同步更新发布日期为当前日期

## 版本管理规则

### 全局版本号
- **唯一来源**: `electron-app/src/version.ts` 中的 `APP_VERSION` 对象
- **版本号格式**: 遵循语义化版本规范 (Semantic Versioning: MAJOR.MINOR.PATCH)
- **修改原则**: 
  - 只在 `version.ts` 中修改版本号
  - 同步更新 `package.json` 中的 version 字段
  - 更新发布日期 releaseDate
- **引用方式**: 所有需要版本号的地方都从 `version.ts` 导入

```typescript
import { APP_VERSION } from './version';
const version = APP_VERSION.version;
```

## 架构规则

### Python 后端 (FastAPI)
- **虚拟环境**: 所有 Python 命令必须在 venv 中执行
  ```bash
  source venv/bin/activate  # 先激活虚拟环境
  python xxx.py
  ```

### 前端架构 (Electron + React)
- **应用类型**: 支持多个独立应用 (voice-note, voice-chat)
- **状态管理**: 使用 React Hooks (useState, useEffect, useRef)
- **通信方式**: WebSocket 用于实时数据流，REST API 用于控制操作

### 数据流规则
- **音频流**: 音频流不经过主窗口，通过 voice_input 虚拟键盘直接流向主窗口
- **不使用"recording"术语**: 将 voice_input 逻辑视为语音输入的虚拟键盘
- **ASR状态**: idle → recording → stopping → idle

## API 响应格式规则

### LLM API 响应格式
AI 助手必须输出 JSON 格式响应，包含以下字段：
```json
{
  "answer_user": "要显示给用户的完整句子",
  "other_data": "其他结构化数据用于处理"
}
```
- **关键规则**: 如果 JSON 中没有 `answer_user` 字段，则不在聊天界面显示任何内容
- **用途**: `answer_user` 用于用户界面展示，其他字段用于程序处理

### 通用 API 响应
```json
{
  "success": true,
  "message": "操作描述",
  "data": {}
}
```

## 代码风格规则

### TypeScript/React
- 使用函数组件和 Hooks
- 组件文件命名: PascalCase (如 `VoiceNote.tsx`)
- 样式文件与组件同名 (如 `VoiceNote.css`)
- 类型定义优先使用 interface
- 避免使用 any，使用具体类型
- Props 类型定义: `interface ComponentNameProps`

### Python
- 遵循 PEP 8 规范
- 类名: PascalCase (如 `BaseASR`)
- 函数/变量名: snake_case (如 `start_recording`)
- 使用类型注解 (Type Hints)
- 文档字符串使用 Google 风格

### 命名规范
- 文件夹: kebab-case (如 `voice-note`)
- 常量: UPPER_SNAKE_CASE (如 `API_BASE_URL`)
- 布尔变量: 使用 is/has/should 前缀 (如 `isConnected`)

## 文件组织规则

### 前端目录结构
```
electron-app/
├── src/
│   ├── components/
│   │   ├── apps/          # 应用组件
│   │   │   ├── VoiceNote/
│   │   │   └── VoiceChat/
│   │   └── shared/        # 共享组件
│   ├── utils/             # 工具函数
│   ├── version.ts         # ⭐ 全局版本号配置
│   ├── App.tsx            # 主应用
│   └── main.tsx
```

### 后端目录结构
```
src/
├── api/                   # API 服务
├── core/                  # 核心功能
├── providers/             # 服务提供者
│   ├── asr/              # 语音识别
│   ├── llm/              # 大语言模型
│   └── storage/          # 存储
└── services/             # 业务服务
```

## 测试规则

### 测试策略
- **仅测试关键模块**: 不需要为所有模块编写测试
- **关键模块**: ASR、LLM、WebSocket 连接、数据存储
- **不创建独立测试程序**: 测试集成在项目中，避免独立测试文件
- **测试类型**: 
  - 单元测试: 核心功能模块
  - 集成测试: 关键业务流程

### ASR 调试日志控制
- **配置文件**: `asr_debug_config.h` (如果存在)
- **控制方式**: 通过注释/取消注释 `#define ASR_LOG_DEBUG` 来开关调试日志
- **不使用 CMake**: 不在 CMake 中定义日志级别，统一在配置头文件中管理

## WebSocket 规则

### 消息类型
```typescript
type WSMessageType = 
  | 'initial_state'  // 初始状态
  | 'text_update'    // 中间结果（实时更新）
  | 'text_final'     // 确定结果（完整utterance）
  | 'state_change'   // 状态变更
  | 'error';         // 错误
```

### 连接管理
- 自动重连: 连接断开后 3 秒自动重连
- 心跳检测: 定期检查 API 连接状态（5秒间隔）
- 状态同步: WebSocket 连接成功后同步初始状态

## 数据持久化规则

### 历史记录
- 每条记录包含: id, text, metadata, created_at, app_type
- app_type: 标识记录来源应用 (voice-note, voice-chat)
- 分页加载: 每页 20 条记录
- 支持按应用类型筛选

### 保存逻辑
```typescript
// 保存时必须指定 app_type
{
  text: string,
  app_type: 'voice-note' | 'voice-chat'
}
```

## 数据库技术规范 ⭐

### 数据库选型
- **主数据库**: SQLite 3
- **位置**: `~/.voice_assistant/history.db`
- **用途**: 存储历史记录、元数据、笔记信息

### 数据库表结构

#### records 表
```sql
CREATE TABLE IF NOT EXISTS records (
    id TEXT PRIMARY KEY,                -- UUID格式记录ID
    text TEXT NOT NULL,                 -- 笔记文本内容
    metadata TEXT,                      -- JSON格式元数据
    app_type TEXT DEFAULT 'voice-note', -- 应用类型
    created_at TIMESTAMP                -- 创建时间（本地时区）
)
```

**字段说明**：
- `id`: 使用 UUID v4，如 `9ca7eb50-d029-4397-8350-ff7e94b2edd9`
- `text`: 纯文本内容，用于搜索和预览
- `metadata`: JSON字符串，包含 blocks、noteInfo 等结构化数据
- `app_type`: 标识来源应用，用于筛选
- `created_at`: **必须使用本地时间**，格式 `YYYY-MM-DD HH:MM:SS`

### metadata 字段结构
```json
{
  "blocks": [
    {
      "id": "block-xxx",
      "type": "paragraph",
      "content": "段落内容",
      "startTime": 1704254400000,
      "endTime": 1704254410000,
      "isAsrWriting": false
    }
  ],
  "noteInfo": {
    "title": "会议纪要",
    "type": "会议",
    "relatedPeople": "张三, 李四",
    "location": "会议室A",
    "startTime": "2026-01-04 10:00:00",
    "endTime": "2026-01-04 11:30:00"
  },
  "language": "zh-CN",
  "provider": "volcano",
  "app_type": "voice-note"
}
```

### 时间处理规范 ⚠️ 重要

#### 规则1：保存时使用本地时间
```python
# Python 后端 - 正确做法
from datetime import datetime

def save_record(self, text: str, metadata: Dict[str, Any]) -> str:
    created_at = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cursor.execute('''
        INSERT INTO records (id, text, metadata, app_type, created_at)
        VALUES (?, ?, ?, ?, ?)
    ''', (record_id, text, json_metadata, app_type, created_at))
```

**禁止做法**：
```python
# ❌ 错误：依赖数据库的 CURRENT_TIMESTAMP（默认UTC时间）
cursor.execute('''
    INSERT INTO records (id, text, metadata, app_type)
    VALUES (?, ?, ?, ?)
''')  # created_at 会自动使用 CURRENT_TIMESTAMP（UTC时间）
```

#### 规则2：路径展开
```python
# ✅ 正确：必须展开 ~ 路径
from pathlib import Path

db_path = config.get('path', 'history.db')
self.db_path = Path(db_path).expanduser()  # 展开 ~ 为用户主目录
```

**禁止做法**：
```python
# ❌ 错误：不展开会创建在项目根目录的 ~ 文件夹
self.db_path = Path(db_path)  # ~/.voice_assistant/history.db 变成 ./~/.voice_assistant/history.db
```

### 数据库操作规范

#### 1. 创建记录
```python
def save_record(self, text: str, metadata: Dict[str, Any]) -> str:
    """保存新记录"""
    import uuid
    record_id = str(uuid.uuid4())
    app_type = metadata.get('app_type', 'voice-note')
    created_at = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    cursor.execute('''
        INSERT INTO records (id, text, metadata, app_type, created_at)
        VALUES (?, ?, ?, ?, ?)
    ''', (record_id, text, json.dumps(metadata, ensure_ascii=False), app_type, created_at))
    
    return record_id
```

#### 2. 更新记录
```python
def update_record(self, record_id: str, text: str, metadata: Dict[str, Any]) -> bool:
    """更新现有记录（增量保存）"""
    cursor.execute('''
        UPDATE records
        SET text = ?, metadata = ?
        WHERE id = ?
    ''', (text, json.dumps(metadata, ensure_ascii=False), record_id))
    
    return cursor.rowcount > 0
```

#### 3. 查询记录
```python
def get_record(self, record_id: str) -> Optional[Dict[str, Any]]:
    """获取单条记录"""
    cursor.execute('''
        SELECT id, text, metadata, app_type, created_at
        FROM records
        WHERE id = ?
    ''', (record_id,))
    
    row = cursor.fetchone()
    if row:
        return {
            'id': row[0],
            'text': row[1],
            'metadata': json.loads(row[2]) if row[2] else {},
            'app_type': row[3] or 'voice-note',
            'created_at': row[4]
        }
    return None
```

#### 4. 列表查询
```python
def list_records(self, limit: int = 100, offset: int = 0, app_type: Optional[str] = None):
    """分页查询记录，支持应用类型筛选"""
    if app_type:
        cursor.execute('''
            SELECT id, text, metadata, app_type, created_at
            FROM records
            WHERE app_type = ?
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        ''', (app_type, limit, offset))
    else:
        cursor.execute('''
            SELECT id, text, metadata, app_type, created_at
            FROM records
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        ''', (limit, offset))
```

### 数据恢复规范

#### 前端恢复逻辑
```typescript
// App.tsx - loadRecord 函数
const loadRecord = async (recordId: string) => {
  const response = await fetch(`${API_BASE_URL}/api/records/${recordId}`);
  const data = await response.json();
  
  if (data.text) {
    setText(data.text);
    
    // 检查是否有 blocks 数据
    if (data.metadata?.blocks && Array.isArray(data.metadata.blocks) && data.metadata.blocks.length > 0) {
      // 有 blocks：直接恢复
      setInitialBlocks(data.metadata.blocks);
    } else {
      // 无 blocks：从纯文本创建
      const textBlocks = data.text.split('\n')
        .filter(line => line.trim())
        .map((line, index) => ({
          id: `block-restored-${Date.now()}-${index}`,
          type: 'paragraph',
          content: line,
          isAsrWriting: false,
        }));
      
      setInitialBlocks([noteInfoBlock, ...textBlocks]);
    }
    
    setActiveView('voice-note');
    startWorkSession('voice-note');
  }
};
```

### 数据库迁移规范

#### 自动迁移逻辑
```python
def _create_table(self):
    """创建表并自动迁移"""
    conn = sqlite3.connect(str(self.db_path))
    cursor = conn.cursor()
    
    # 创建表
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS records (
            id TEXT PRIMARY KEY,
            text TEXT NOT NULL,
            metadata TEXT,
            app_type TEXT DEFAULT 'voice-note',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # 检查是否需要添加字段
    cursor.execute("PRAGMA table_info(records)")
    columns = [col[1] for col in cursor.fetchall()]
    
    if 'app_type' not in columns:
        cursor.execute('ALTER TABLE records ADD COLUMN app_type TEXT DEFAULT "voice-note"')
        logger.info("[Storage] 数据库迁移：已添加 app_type 字段")
    
    conn.commit()
    conn.close()
```

### 常见问题和解决方案

#### 问题1：时间显示相差8小时
**原因**：数据库使用 UTC 时间，前端未转换  
**解决**：保存时使用 `datetime.now()` 而非 `CURRENT_TIMESTAMP`

#### 问题2：路径展开失败
**原因**：`Path(~)` 不会自动展开波浪号  
**解决**：使用 `Path().expanduser()`

#### 问题3：恢复内容为空
**原因**：`blocks` 为 `null`，但未从纯文本创建  
**解决**：检查 `blocks` 存在性和长度，不存在时从 `text` 创建

#### 问题4：多个数据库文件
**原因**：路径配置错误或路径未展开  
**解决**：确保使用 `.expanduser()` 并检查配置路径

### 数据库维护

#### 数据备份
```bash
# 手动备份
cp ~/.voice_assistant/history.db ~/.voice_assistant/history.db.backup

# 查看记录数
sqlite3 ~/.voice_assistant/history.db "SELECT COUNT(*) FROM records;"
```

#### 数据清理
```python
def delete_old_records(self, days: int = 90):
    """删除N天前的记录"""
    cutoff_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')
    cursor.execute('DELETE FROM records WHERE created_at < ?', (cutoff_date,))
```

### 性能优化

#### 索引建议
```sql
-- 为常用查询字段创建索引
CREATE INDEX idx_created_at ON records(created_at DESC);
CREATE INDEX idx_app_type ON records(app_type);
CREATE INDEX idx_app_type_created_at ON records(app_type, created_at DESC);
```

#### 批量操作
```python
# 使用事务批量插入
conn = self._get_connection()
try:
    cursor = conn.cursor()
    cursor.executemany('''
        INSERT INTO records (id, text, metadata, app_type, created_at)
        VALUES (?, ?, ?, ?, ?)
    ''', records_batch)
    conn.commit()
except Exception as e:
    conn.rollback()
    raise
finally:
    conn.close()
```

## 错误处理规则

### 前端错误处理
- 网络错误: 显示 Toast 提示，不中断用户操作
- API 错误: 显示错误横幅，提供重试机制
- WebSocket 错误: 自动重连，不打断用户

### 后端错误处理
- 返回统一错误格式
- 记录详细错误日志
- 区分用户错误和系统错误

## UI/UX 规则

### 状态指示
- ASR 状态: 通过 StatusIndicator 组件显示
- 连接状态: API 连接状态实时显示
- 加载状态: 使用 loading 状态避免重复点击

### Toast 通知
- 成功操作: 'success' 类型（绿色）
- 错误操作: 'error' 类型（红色）
- 提示信息: 'info' 类型（蓝色）
- 自动关闭: 3秒后自动消失

## 配置管理规则

### 配置文件
- 示例配置: `config.yml.example`
- 实际配置: `config.yml` (不提交到版本控制)
- 配置加载: 启动时从 config.yml 加载

### 配置文件同步规则 ⭐
- **重要原则**: 添加或修改配置项时，必须**同时更新** `config.yml` 和 `config.yml.example`
- **同步范围**: 
  - ✅ 配置项的键名和结构
  - ✅ 配置项的注释和说明
  - ✅ 配置项的默认值
  - ❌ 令牌、密钥等敏感信息（仅在 `config.yml` 中有真实值）
- **示例配置文件规则**:
  - `config.yml.example` 中的密钥/令牌字段留空或使用占位符（`""`）
  - 必须包含详细的注释说明每个配置项的用途
- **实际配置文件规则**:
  - `config.yml` 包含真实的密钥和令牌
  - 不提交到版本控制（已在 `.gitignore` 中）
  
**修改流程**:
1. 在 `config.yml.example` 中添加新配置项（带注释）
2. 在 `config.yml` 中添加相同配置项（可含真实值）
3. 确保两个文件的结构一致

### 环境变量
- API 地址: `API_BASE_URL`
- WebSocket 地址: `WS_URL`
- 开发环境使用本地地址

## Git 规则

### 提交信息格式
```
<type>(<scope>): <subject>

type: feat|fix|docs|style|refactor|test|chore
scope: component|api|asr|llm|ui
subject: 简短描述（中文）
```

示例:
```
feat(ui): 添加关于页面
fix(asr): 修复WebSocket重连问题
docs(readme): 更新安装说明
```

### 不提交的文件
- `venv/` - Python 虚拟环境
- `node_modules/` - Node 依赖
- `config.yml` - 配置文件
- `*.pyc` - Python 编译文件
- `dist/` - 构建产物

## 性能优化规则

### 前端性能
- 使用 React.memo 避免不必要的重渲染
- 大列表使用虚拟滚动
- 防抖/节流处理高频事件

### 后端性能
- 异步处理音频流
- 使用连接池管理数据库连接
- 实现合理的缓存策略

## 安全规则

### API 安全
- 输入验证: 所有用户输入必须验证
- XSS 防护: 文本内容正确转义
- CORS 配置: 仅允许特定来源

### 数据安全
- 敏感信息不记录到日志
- API Key 存储在配置文件中
- 不在前端暴露敏感配置

## 文档规则

### 代码注释
- 复杂逻辑必须添加注释
- 公共 API 必须有文档字符串
- 注释使用中文，清晰简洁

### 项目文档
- `README.md`: 项目介绍和快速开始
- `docs/`: 详细架构和设计文档
- 重要变更更新 CHANGELOG

## 开发工具规则

### 推荐扩展
- ESLint: 代码检查
- Prettier: 代码格式化
- Python (Pylance): Python 支持

### 命令快捷方式
```bash
# 启动开发服务
./quick_start.sh

# 停止服务
./stop.sh
```

## 关于页面规则

### 必需信息
- 开发者: 深圳王哥 & AI
- 联系方式: manwjh@126.com
- 版本号: 从 `version.ts` 导入
- 发布日期: 从 `version.ts` 导入

### 版本更新流程
1. 修改 `electron-app/src/version.ts`
2. 同步更新 `electron-app/package.json` 的 version 字段
3. 更新 releaseDate 为发布日期（使用当前实际日期）
4. 在 CHANGELOG 中记录变更（如果有）

### 快捷更新方式
使用提供的脚本快速更新版本号：
```bash
# 自动使用当前日期作为发布日期
./update_version.sh 1.1.0

# 或指定发布日期
./update_version.sh 1.1.0 2025-12-31
```

---

**注意**: 这些规则是项目的编码标准，所有贡献者必须遵守。如有疑问或需要调整规则，请与项目维护者讨论。

