# ASR队列诊断日志说明

## 更新日期
2026-01-05

## 目的
为了诊断ASR停止时的6秒延迟问题，在关键位置添加了详细日志。

## 新增日志点

### 1. 音频入队日志 (send_audio_chunk)

**位置**: `src/providers/asr/volcano.py` - `send_audio_chunk()`

**日志格式**:
```
[ASR-Queue] 入队成功: seq={序列号}, 数据={字节数}B, 队列深度={队列大小}
```

**记录频率**: 每100个音频块记录一次

**作用**: 监控音频数据进入ASR队列的速度和队列积压情况

### 2. 发送器线程日志 (_audio_sender)

**位置**: `src/providers/asr/volcano.py` - `_audio_sender()`

#### 2.1 启动日志
```
[ASR-Sender] 发送器线程开始运行
```

#### 2.2 队列取出日志
```
[ASR-Sender] 从队列取出数据: 取出前队列={大小}, 取出后队列={大小}
```
**记录频率**: 每100个包记录一次

#### 2.3 发送进度日志
```
[ASR-Sender] 已发送 {数量} 个音频包 (seq={序列号}, 队列剩余={大小})
```
**记录频率**: 每100个包记录一次

#### 2.4 结束标记日志
```
[ASR-Sender] 收到结束标记 (已发送{总数}个音频包，队列剩余={大小})
```

#### 2.5 结束日志
```
[ASR-Sender] 发送器线程结束，共发送 {总数} 个音频包
[ASR-Sender] 发送器任务被取消
```

### 3. 停止识别日志 (stop_streaming_recognition)

**位置**: `src/providers/asr/volcano.py` - `stop_streaming_recognition()`

**日志格式**:
```
[ASR-Queue] 发送结束标记，当前队列深度={大小}
```

**作用**: 记录停止时队列的积压情况

### 4. 语音服务停止日志 (_on_speech_end)

**位置**: `src/services/voice_service.py` - `_on_speech_end()`

**日志格式**:
```
[语音服务] 准备发送结束标记，ASR队列当前深度={大小}
[语音服务] 已发送结束标记，等待ASR返回最后结果...
```

**作用**: 追踪用户点击停止按钮时的队列状态

## 诊断方法

### 关键时间点追踪

1. **用户点击停止**
   ```
   [语音服务] 停止录音... (app_id=voice-note)
   [语音服务] AudioASRGateway 触发：停止ASR（发送结束标记）
   [语音服务] 准备发送结束标记，ASR队列当前深度={X}
   ```

2. **发送器收到结束标记**
   ```
   [ASR-Sender] 收到结束标记 (已发送{Y}个音频包，队列剩余={Z})
   ```

3. **最后包发送**
   ```
   [ASR-WS] → 最后音频包 (seq=-{N}, 6400B)
   ```

### 诊断指标

#### 队列积压判断
- **队列深度 < 10**: 正常，实时消费
- **队列深度 10-50**: 轻度积压
- **队列深度 50-200**: 中度积压，可能有1-2秒延迟
- **队列深度 > 200**: 严重积压，停止时会有明显延迟

#### 生产消费比
```
生产速度 = 5块/秒 (每200ms一块)
消费速度 = (发送总数) / (录音时长)
```

如果消费速度 < 生产速度，说明发送瓶颈存在。

#### 停止延迟计算
```
停止延迟 = (队列剩余数量) / (发送速度)
```

### 分析步骤

1. **检查队列是否积压**
   ```bash
   grep "ASR队列当前深度" logs/api_server_*.log
   ```

2. **统计发送速度**
   ```bash
   grep "已发送.*个音频包" logs/api_server_*.log | tail -5
   ```

3. **计算时间差**
   ```bash
   # 找到停止时间和最后包发送时间
   grep "停止录音\|最后音频包" logs/api_server_*.log
   ```

4. **分析瓶颈**
   - 如果队列深度一直很小（<10），说明消费正常
   - 如果队列深度持续增长，说明发送速度跟不上
   - 检查网络延迟、WebSocket连接质量

## 预期结果

### 正常情况（无积压）
```
23:45:41 - [语音服务] 准备发送结束标记，ASR队列当前深度=2
23:45:41 - [ASR-Sender] 收到结束标记 (已发送2312个音频包，队列剩余=1)
23:45:41 - [ASR-WS] → 最后音频包 (seq=-2315, 6400B)
```
**延迟**: < 0.5秒

### 异常情况（有积压）
```
23:45:41 - [语音服务] 准备发送结束标记，ASR队列当前深度=500
23:45:44 - [ASR-Sender] 收到结束标记 (已发送2312个音频包，队列剩余=150)
23:45:47 - [ASR-WS] → 最后音频包 (seq=-2815, 6400B)
```
**延迟**: 6秒（需要发送500个积压的包）

## 后续优化方向

根据日志分析结果，可能的优化方案：

1. **限制队列深度**: `asyncio.Queue(maxsize=50)`
2. **提高发送速度**: 减小音频块大小或批量发送
3. **异步停止**: 不等待队列清空，直接返回给用户
4. **队列监控**: 实时监控队列深度，超过阈值时告警

## 使用建议

1. **开发环境**: 建议开启DEBUG日志级别查看详细队列信息
2. **生产环境**: 保持INFO级别，每100个包记录一次不会影响性能
3. **问题排查**: 发现延迟问题时，查看日志中的队列深度变化趋势

