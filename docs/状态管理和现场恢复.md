# 语音笔记 - 状态管理和现场恢复机制

## 📋 任务状态定义

### 1. 新建状态 (New)
**触发条件**：
- 首次打开应用
- 点击 EXIT 按钮退出当前任务
- 手动创建新笔记

**状态特征**：
- `isWorkSessionActive = false`
- `currentRecordId = null`
- `initialBlocks = undefined`
- UI 显示：欢迎界面

**用户操作**：
- 点击"开始工作"按钮 → 进入"工作中"状态
- 开始输入或语音识别 → 自动进入"工作中"状态

---

### 2. 工作中状态 (Working)
**触发条件**：
- 点击"开始工作"按钮
- 开始输入内容或语音识别
- 从历史记录恢复任务
- 从其他视图返回并恢复工作现场

**状态特征**：
- `isWorkSessionActive = true`
- `currentRecordId = <uuid>`（首次保存后生成）
- `initialBlocks = [...]`（包含编辑内容）
- UI 显示：BlockEditor 编辑器

**自动保存触发**：
- ✏️ **编辑完成** (`edit_complete`): block 失焦时
- ✅ **Block 确定** (`block_confirmed`): ASR 识别完成一个句子
- 📝 **手动编辑** (节流30秒): 用户手动编辑内容
- ⏱️ **定期保存** (`periodic`): 每 60 秒
- 🔄 **切换视图** (`view_switch`): 离开语音笔记时

**用户操作**：
- 继续编辑 → 保持"工作中"状态
- 切换到其他视图 → **保存工作现场**，切换后可恢复
- 点击 EXIT → 保存并进入"新建"状态

---

### 3. 退出状态 (Exited)
**触发条件**：
- 点击 EXIT 按钮并确认保存

**状态特征**：
- 执行 `exitWithSave()` 保存当前内容
- 执行 `endWorkSession()` 清空所有状态
- 执行 `voiceNoteAutoSave.reset()` 重置自动保存服务
- 回到"新建"状态

**操作流程**：
```
点击 EXIT 
  → 检查 ASR 是否 idle
  → 保存当前 blocks 和 noteInfo 到数据库
  → 清空 initialBlocks、text、currentRecordId
  → 重置 AutoSave
  → 显示欢迎界面
```

---

## 🔄 现场恢复机制

### 恢复触发时机

#### 自动恢复（实现中）
当用户从其他视图**返回语音笔记**时：
1. 检测到 `activeView !== 'voice-note' → 'voice-note'`
2. 调用 `voiceNoteAutoSave.recover()`
3. 如果有可恢复的记录，自动加载并激活工作会话

#### 手动恢复
用户从**历史记录**点击"恢复"按钮：
1. 调用 `loadRecord(recordId)`
2. 加载指定记录的 blocks 和 noteInfo
3. 切换到语音笔记视图
4. 激活工作会话

### 恢复数据优先级

```
1. localStorage 临时数据（5分钟内，且比数据库更新）
   ↓ 如果不存在或过期
2. 数据库最新记录（24小时内）
   ↓ 如果不存在或过期
3. 不恢复（显示欢迎界面）
```

### 恢复逻辑详解

#### 1. 时间检查
```typescript
recoverTimeLimit: 86400000  // 24小时（可配置）
```
- **目的**：避免恢复过旧的记录
- **24小时**：支持跨天恢复，适合用户第二天继续工作

#### 2. localStorage 优先
```typescript
volatileDataPriority: 300000  // 5分钟
```
- **场景**：用户正在编辑，但还未失焦保存到数据库
- **条件**：localStorage 数据更新 + 在5分钟内

#### 3. 数据库恢复
```typescript
// 获取最新的 voice-note 记录
GET /api/records?limit=1&app_type=voice-note

// 恢复记录
currentRecordId = latestRecord.id
initialBlocks = latestRecord.metadata.blocks
noteInfo = latestRecord.metadata.noteInfo
```

---

## 🎯 用户场景示例

### 场景 1: 临时切换视图
**操作流程**：
1. 用户在语音笔记中编辑："今天的会议记录..."
2. 切换到"历史记录"查看旧笔记 → **自动保存当前内容**
3. 切换回"语音笔记" → **自动恢复工作现场**
4. 继续编辑："...讨论了项目进度"

**状态变化**：
```
工作中 → 保存(view_switch) → 切换视图 → 返回 → 恢复工作现场 → 工作中
```

---

### 场景 2: 退出后重新开始
**操作流程**：
1. 用户完成笔记："今天的会议记录..."
2. 点击 EXIT → **保存并清空**
3. 显示欢迎界面
4. 点击"开始工作" → **全新的笔记**

**状态变化**：
```
工作中 → EXIT → 保存并清空 → 新建 → 开始工作 → 工作中（新记录）
```

---

### 场景 3: 从历史记录恢复
**操作流程**：
1. 切换到"历史记录"
2. 找到昨天的笔记
3. 点击"恢复" → **加载历史记录**
4. 自动切换到语音笔记 + 激活工作会话
5. 继续编辑

**状态变化**：
```
新建/工作中 → 历史记录 → 恢复(recordId) → 工作中（恢复的记录）
```

---

### 场景 4: 意外关闭/刷新
**操作流程**：
1. 用户正在编辑，但浏览器意外关闭
2. 重新打开应用
3. **自动恢复**（如果在24小时内）
4. 继续编辑

**状态变化**：
```
工作中 → [意外关闭] → 重新打开 → 自动恢复 → 工作中
```

---

## ⚙️ 配置参数

### AutoSaveService 配置
```typescript
const DEFAULT_CONFIG = {
  localStorageInterval: 1000,      // localStorage保存间隔：1秒
  dbSaveDebounce: 3000,            // 数据库保存防抖：3秒
  longEditThreshold: 30000,        // 长时间编辑兜底：30秒
  periodicSaveInterval: 60000,     // 定期保存间隔：60秒
  recoverTimeLimit: 86400000,      // 恢复时间限制：24小时
  volatileDataPriority: 300000,    // 临时数据优先时限：5分钟
};
```

### 自定义配置
```typescript
const autoSave = new AutoSaveService('voice-note', adapter, {
  recoverTimeLimit: 7200000,  // 修改为2小时
});
```

---

## 🔍 调试日志

### 保存触发日志
```
[AutoSave-voice-note] 💾 saveToDatabase 调用 { trigger, immediate }
[AutoSave-voice-note] ⏱️  防抖：启动定时器 3000ms
[AutoSave-voice-note] ⏰ 防抖时间到，执行保存
[AutoSave-voice-note] 🚀 开始执行保存
[VoiceNoteAdapter] 🔍 getStableData - allData
[VoiceNoteAdapter] 💾 toSaveData 输出
[AutoSave-voice-note] ✅ 创建/更新记录成功
```

### 现场恢复日志
```
[导航] 返回语音笔记，尝试恢复工作现场
[AutoSave-voice-note] 从数据库恢复: <recordId>
[导航] 恢复工作现场成功 { blocksCount, hasNoteInfo, recordId }
```

---

## 🚀 实现状态

- ✅ 自动保存（edit_complete, block_confirmed, periodic, view_switch）
- ✅ localStorage 临时保存（每秒）
- ✅ 数据库持久化（防抖3秒）
- ✅ 手动恢复（从历史记录）
- ✅ 自动恢复（切换视图返回）
- ✅ 24小时恢复时限
- ✅ 状态管理（新建/工作中/退出）

---

## 📝 注意事项

1. **EXIT vs 切换视图**
   - EXIT: 清空所有状态，开始全新记录
   - 切换视图: 保留状态，支持恢复

2. **currentRecordId 的作用**
   - 首次保存时创建（POST /api/text/save）
   - 后续更新使用（PUT /api/records/{id}）
   - 确保所有修改都保存到同一条记录

3. **自动恢复的限制**
   - 只恢复 24 小时内的记录
   - 如果有多个设备，以最新的数据库记录为准
   - localStorage 临时数据仅在同一浏览器/设备有效

4. **性能优化**
   - 防抖3秒：避免频繁保存
   - 节流30秒：手动编辑触发
   - 定期60秒：兜底保存

---

## 🔮 未来改进

1. **多设备同步**
   - 支持云端存储
   - 冲突解决机制

2. **版本历史**
   - 记录每次修改的快照
   - 支持回退到历史版本

3. **离线支持**
   - Service Worker 缓存
   - 离线编辑，在线同步

4. **智能恢复提示**
   - 检测到可恢复的记录时，询问用户是否恢复
   - 显示恢复内容的预览

