# 音频缓冲区内存泄漏修复文档

## 问题描述

在长时间录音场景（如1小时演讲视频）中，系统出现以下问题：
1. **延迟越来越长**：后期延迟可能长达数十秒
2. **内存持续增长**：缓冲区累积到上百MB
3. **性能逐渐下降**：处理速度变慢

## 问题原因

从日志分析可以看到：

```log
2026-01-02 11:43:46 - [音频] 消费音频块 #19500, 大小=6400字节, 缓冲区总大小=124800000字节
2026-01-02 11:44:06 - [音频] 消费音频块 #19600, 大小=6400字节, 缓冲区总大小=125440000字节
2026-01-02 11:45:26 - [音频] 消费音频块 #20000, 大小=6400字节, 缓冲区总大小=128000000字节
2026-01-02 11:46:07 - [音频] 录音统计: 共采集 20202 个音频块，总计 129292800 字节
```

**根本原因**：
- 音频数据通过 `self.audio_buffer.extend(data)` 持续累积
- **从不清理已处理的数据**
- 长时间录音导致缓冲区无限增长（约33分钟累积到123MB）

## 解决方案

### 1. 添加缓冲区大小限制

在 `SoundDeviceRecorder` 初始化时添加 `max_buffer_seconds` 参数：

```python
def __init__(self, ..., max_buffer_seconds: int = 60):
    # 计算最大缓冲区大小（字节）
    # 采样率 * 通道数 * 2字节(int16) * 秒数
    self.max_buffer_size = rate * channels * 2 * max_buffer_seconds
```

### 2. 自动清理旧数据

在 `_consume_audio` 方法中添加缓冲区管理逻辑：

```python
def _consume_audio(self):
    while self.running:
        data = self.audio_queue.get(timeout=0.1)
        if not self.paused:
            self.audio_buffer.extend(data)
            
            # 缓冲区大小管理
            buffer_size = len(self.audio_buffer)
            if buffer_size > self.max_buffer_size:
                # 保留最新的一半数据，删除旧的一半
                keep_size = self.max_buffer_size // 2
                remove_size = buffer_size - keep_size
                self.audio_buffer = self.audio_buffer[remove_size:]
                self._buffer_cleanups += 1
                logger.info(f"[音频] 缓冲区清理: 删除了 {remove_size // 1024 // 1024}MB 旧数据")
```

### 3. 配置文件支持

在 `config.yml` 中添加配置项：

```yaml
audio:
  max_buffer_seconds: 60  # 最大缓冲时长（秒）
  
  # 说明：
  # - 16kHz单声道：60秒约1.92MB，120秒约3.84MB
  # - 建议值：60秒（1分钟）- 120秒（2分钟）
  # - 实时ASR不受影响，音频数据已通过流式发送给ASR服务
```

## 修改文件清单

### 1. `src/utils/audio_recorder.py`
- 添加 `max_buffer_seconds` 参数（默认60秒）
- 添加 `max_buffer_size` 计算
- 添加 `_buffer_cleanups` 统计计数器
- 在 `_consume_audio` 中实现自动清理逻辑
- 添加缓冲区清理日志输出

### 2. `config.yml.example` 和 `config.yml`
- 在 `audio` 部分添加 `max_buffer_seconds` 配置项
- 添加详细的配置说明和建议值

### 3. `src/api/server.py`
- 在创建 `SoundDeviceRecorder` 时传递 `max_buffer_seconds` 参数
- 从配置文件读取值，默认60秒

## 效果预期

### 内存使用
- **修复前**：1小时录音累积约200-300MB
- **修复后**：最大保持约1.92MB（60秒）或3.84MB（120秒）

### 性能提升
- 消除延迟累积问题
- 保持稳定的处理速度
- 降低内存压力

### 功能保证
- ✅ 实时ASR不受影响（数据已通过回调发送）
- ✅ VAD过滤正常工作
- ✅ 可配置缓冲区大小
- ✅ 向后兼容（默认值60秒）

## 缓冲区大小建议

根据采样率和通道数计算：

| 采样率 | 通道 | 60秒 | 120秒 | 180秒 |
|--------|------|------|-------|-------|
| 16kHz  | 单声道 | 1.92MB | 3.84MB | 5.76MB |
| 16kHz  | 立体声 | 3.84MB | 7.68MB | 11.52MB |
| 44.1kHz | 单声道 | 5.29MB | 10.58MB | 15.87MB |

**推荐配置**：
- **语音识别场景**：60秒（足够保留最近上下文）
- **音乐/高质量场景**：120-180秒
- **极限长时录音**：60秒（最小化内存占用）

## 日志监控

启用后会看到以下日志：

### 初始化日志
```log
[音频] 初始化音频录制器: rate=16000Hz, channels=1, chunk=3200, device=1
[音频] 缓冲区管理: 最大缓冲60秒 (约1MB)
```

### 运行时清理日志
```log
[音频] 缓冲区清理: 删除了 1MB 旧数据, 保留最近 0MB, 累计清理 1 次
[音频] 缓冲区清理: 删除了 1MB 旧数据, 保留最近 0MB, 累计清理 2 次
```

### 停止时统计日志
```log
[音频] 音频消费线程结束，共消费 20202 个音频块
[音频] 缓冲区清理统计: 共清理 35 次
```

## 测试验证

### 测试场景
1. ✅ 短时录音（< 1分钟）：正常工作，无清理
2. ✅ 中等时长（5-10分钟）：偶尔清理，性能稳定
3. ✅ 长时录音（1小时+）：定期清理，内存稳定

### 测试方法
```bash
# 1. 启动服务
./quick_start.sh

# 2. 开始录音
# 3. 观察日志中的缓冲区清理信息
# 4. 验证ASR识别结果正常
# 5. 检查内存占用稳定
```

## 注意事项

1. **不影响ASR功能**：音频数据已通过 `on_audio_chunk` 回调实时发送给ASR
2. **无法保存完整录音**：如需保存完整音频文件，需要另外实现（建议使用文件流写入）
3. **配置灵活性**：可根据实际需求调整 `max_buffer_seconds`
4. **向后兼容**：未配置时使用默认值60秒

## 未来优化方向

1. **分段存储**：使用链表或分段数组，避免大块内存复制
2. **可选完整录音**：添加开关控制是否保存完整音频
3. **动态调整**：根据内存压力自动调整缓冲区大小
4. **压缩存储**：对历史数据进行压缩存储

## 相关Issue

- 问题报告：长时间录音延迟增加
- 修复日期：2026-01-02
- 影响版本：v1.0.0及更早版本
- 修复版本：v1.0.1+

---

**总结**：通过添加缓冲区大小限制和自动清理机制，彻底解决了长时间录音导致的内存泄漏和延迟累积问题。

